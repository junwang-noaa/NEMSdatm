subroutine AtmGridSetUp(grid,petCnt,gridname,tag,rc)

#include "LocalDefs.F90"

  use ESMF
  use AtmInternalFields, only : lPet, iatm, jatm, dirpath, cdate0, filename_base
  use AtmInternalFields, only : AtmIndexType, extended_lmsk

  use AtmGridUtils

  implicit none

  type(ESMF_Grid)         :: grid

           integer, intent( in) :: petCnt
  character(len=*), intent( in) :: gridname,tag
           integer, intent(out) :: rc

  ! Local variables
  type(ESMF_Array)                 :: array2d

  character(len=ESMF_MAXSTR) :: filename
  character(len=ESMF_MAXSTR) :: msgString

  integer :: i,j,lde,peX,peY,peList(2),localDECount
  integer(kind=ESMF_KIND_I4), pointer  :: i4Ptr(:,:)
  
  integer(kind=ESMF_KIND_I4), allocatable :: cppeX(:), cppeY(:)

  ! gaussian grid center coords
  real(kind=ESMF_KIND_R8), allocatable :: coordXc(:),coordYc(:)
  ! gaussian grid corner coords
  real(kind=ESMF_KIND_R8), allocatable :: coordXq(:),coordYq(:)
  ! gaussian grid landsfc mask
  real(kind=ESMF_KIND_R4), allocatable :: landsfc(:,:)

  filename = trim(dirpath)//trim(filename_base)//trim(cdate0)//'.nc'

  rc = ESMF_SUCCESS

  call ESMF_LogWrite(trim(tag)//" AtmGridSetUp routine started", ESMF_LOGMSG_INFO)
  write(msgString,*)'using grid file : ',trim(filename)
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
  write(msgString,*)'petCnt = ',petCnt,' lPet =  ', lPet
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
#ifdef test
  ! specifying distribution not working; use default distribution
  if(petCnt == 1)then
  !serial
   peList = (/1,1/)
  else
   if(mod(petCnt,6) .ne. 0)then
    write(msgString,*)'must use multiple of 6 PEs; Aborting '
    call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
    call ESMF_Finalize(endflag = ESMF_END_ABORT)
   else
       peX = 2*petCnt/3
       peY =   petCnt/3
    peList = (/peX, peY/)
     allocate(cppeX(1:peX))
     allocate(cppeY(1:peY))
     cppeX(:) = iatm/peX
     cppeY(:) = jatm/peY
    write(msgString,*)'petCnt = ',petCnt,' peX,peY = ',peX,peY
    call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
   endif
  endif
#endif
  !-------------------------------------------------------------------------------------
  ! read Gaussian coords from file. Native EMSF_ArrayRead does not read Y coord from
  ! file correctly
  !-------------------------------------------------------------------------------------

  allocate(coordXc(1:iatm)); allocate(coordXq(1:iatm  ))
  allocate(coordYc(1:jatm)); allocate(coordYq(1:jatm+1))

  call ReadCoordFromFile(trim(filename),trim('lon'),iatm,coordXc)
  call ReadCoordFromFile(trim(filename),trim('lat'),jatm,coordYc)

  write(msgString,*)'coordXc,   ',lPet,minval(real(coordXc,4)), &
                                       maxval(real(coordXc,4))
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
  write(msgString,*)'coordYc,   ',lPet,minval(real(coordYc,4)), &
                                       maxval(real(coordYc,4))
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)

  ! create corner points; npole at j=1, spole at j=jatm+1
           j = 1
  coordYq(j) =  90.0_ESMF_KIND_R8
           j = jatm+1
  coordYq(j) = -90.0_ESMF_KIND_R8
  do j = 2,jatm
   coordYq(j) = (coordYc(j-1) + coordYc(j))*0.5_ESMF_KIND_R8
  enddo
   
  ! like module_CPLFIELDS.F90 in GSM
  do i = 1,iatm
   coordXq(i) = 360.0_ESMF_KIND_R8/real(iatm) * (real(i) - 1.5_ESMF_KIND_R8)
  enddo
  
  write(msgString,*)'coordXq,   ',lPet,minval(real(coordXq,4)), &
                                       maxval(real(coordXq,4))
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
  write(msgString,*)'coordYq,   ',lPet,minval(real(coordYq,4)), &
                                       maxval(real(coordYq,4))
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)

  !-------------------------------------------------------------------------------------
  ! ESMF_ArrayRead can read the mask from the file, but it is the wrong type (r4) and
  ! so requires working around that. Easier to just get global mask array like for the
  ! coords
  !-------------------------------------------------------------------------------------

  allocate(landsfc(1:iatm,1:jatm))
  call ReadMaskFromFile(trim(filename), trim('slmsksfc'), landsfc)

  !-------------------------------------------------------------------------------------
  ! Create the gaussian grid and fill the coords and mask
  ! for now, this defaults to the default distribution where the first dimension is
  ! decomposed with all PEs
  !-------------------------------------------------------------------------------------
  grid = ESMF_GridCreate1PeriDim(maxIndex = (/iatm,jatm/), &
  !                               regDecomp = peList, &
                                 coordDep1=(/1,2/), &            ! grid is defined with 2d
                                 coordDep2=(/1,2/), &            ! lat,lon arrays
                                 periodicDim=1,&
                                 poleDim=2,&
                                 polekindflag=(/ESMF_POLEKIND_MONOPOLE, &
                                                ESMF_POLEKIND_MONOPOLE/), &
                                 indexflag=AtmIndexType, &
                                 name=trim(gridname), rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out

  call ESMF_GridGet(grid, localDECount=localDECount, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out

  write(msgString,*)'localDECount ',lPet,localDECount
  call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
  !-------------------------------------------------------------------------------------
  ! Allocate storage for coords and mask
  !-------------------------------------------------------------------------------------
  ! P (Center) stagger
  call ESMF_GridAddCoord(grid, &
                         staggerloc=ESMF_STAGGERLOC_CENTER, &
                         rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out

  ! Q (Corner) stagger
  call ESMF_GridAddCoord(grid, &
                         staggerloc=ESMF_STAGGERLOC_CORNER, &
                         rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out

  ! Mask
  call ESMF_GridAddItem(grid, &
                        staggerloc=ESMF_STAGGERLOC_CENTER, &
                        itemFlag=ESMF_GRIDITEM_MASK, &
                        itemTypeKind=ESMF_TYPEKIND_I4, &
                        rc = rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out
  !-------------------------------------------------------------------------------------
  ! Add coords
  !-------------------------------------------------------------------------------------

  call AddCoord2Grid(grid, ESMF_STAGGERLOC_CENTER, iatm, jatm  , coordXc, coordYc, rc)
  call AddCoord2Grid(grid, ESMF_STAGGERLOC_CORNER, iatm, jatm+1, coordXq, coordYq, rc)

  !-------------------------------------------------------------------------------------
  ! Add mask 
  !-------------------------------------------------------------------------------------

  ! retrieve a pointer for the mask
  call ESMF_GridGetItem(grid, localDE=0,&
                        staggerloc=ESMF_STAGGERLOC_CENTER, &
                        itemFlag=ESMF_GRIDITEM_MASK, &
                        farrayPtr=i4Ptr, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, &
    file=__FILE__)) &
    return  ! bail out

  !fill the value using the landsfc mask
  i4Ptr = 0
  do j = lbound(i4Ptr,2),ubound(i4Ptr,2)
    do i = lbound(i4Ptr,1),ubound(i4Ptr,1)
     if (nint(landsfc(i,j)) == 1) then
       i4Ptr(i,j) = nint(landsfc(i,j))
     endif
     if(extended_lmsk) then
 
       if (nint(landsfc(i,j)) == 0) then
         if (i > lbound(i4Ptr,1)) then
           if(nint(landsfc(i-1,j)) == 1) i4Ptr(i,j) = 1
         endif
         if (i < ubound(i4Ptr,1)) then
           if(nint(landsfc(i+1,j)) == 1) i4Ptr(i,j) = 1
         endif
         if (j > lbound(i4Ptr,2)) then
           if(nint(landsfc(i,j-1)) == 1) i4Ptr(i,j) = 1
         endif
         if (i < ubound(i4Ptr,2)) then
           if(nint(landsfc(i,j+1)) == 1) i4Ptr(i,j) = 1
         endif
       endif

     endif

    enddo
  enddo

  !-------------------------------------------------------------------------------------
  ! Write coords and mask to file
  !-------------------------------------------------------------------------------------

  call WriteCoord(grid, ESMF_STAGGERLOC_CENTER, 1, 'atmlonc', lPet, rc)
  call WriteCoord(grid, ESMF_STAGGERLOC_CENTER, 2, 'atmlatc', lPet, rc)
  call WriteCoord(grid, ESMF_STAGGERLOC_CORNER, 1, 'atmlonq', lPet, rc)
  call WriteCoord(grid, ESMF_STAGGERLOC_CORNER, 2, 'atmlatq', lPet, rc)

  call  WriteMask(grid, ESMF_STAGGERLOC_CENTER, 'atmmask', lPet, rc)

  deallocate(coordXc); deallocate(coordXq)
  deallocate(coordYc); deallocate(coordYq)
  deallocate(landsfc)

  !deallocate(cppeX); deallocate(cppeY)
  call ESMF_LogWrite("User AtmGridSetUp routine ended", ESMF_LOGMSG_INFO)

end subroutine AtmGridSetUp
